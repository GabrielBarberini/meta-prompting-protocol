from __future__ import annotations

from typing import Any

import dspy


class ProtocolArchitect(dspy.Signature):
    """Generate an MPP bundle from a high-level user goal, ideally via refinement."""

    user_goal: str = dspy.InputField(desc="High-level user goal to be encoded.")
    meta_protocol_version: str = dspy.OutputField(
        desc="MPP spec version (e.g., 1.2.0)."
    )
    derivative_protocol_specification: dict[str, Any] = dspy.OutputField(
        desc="Derivative protocol specification object."
    )
    derivative_protocol_payload: dict[str, Any] = dspy.OutputField(
        desc="Payload encoded according to the derivative protocol."
    )


class ProtocolExecutor(dspy.Signature):
    """Execute an MPP bundle, ideally via decode/validate refinement."""

    meta_protocol_version: str = dspy.InputField(desc="MPP spec version.")
    derivative_protocol_specification: dict[str, Any] = dspy.InputField(
        desc="Derivative protocol specification object."
    )
    derivative_protocol_payload: dict[str, Any] = dspy.InputField(
        desc="Payload encoded according to the derivative protocol."
    )
    final_response: str = dspy.OutputField(
        desc="Task output generated by the ProtocolExecutor."
    )


class QualityAssurance(dspy.Signature):
    """Validate the ProtocolExecutor output against the bundle."""

    meta_protocol_version: str = dspy.InputField(desc="MPP spec version.")
    derivative_protocol_specification: dict[str, Any] = dspy.InputField(
        desc="Derivative protocol specification object."
    )
    derivative_protocol_payload: dict[str, Any] = dspy.InputField(
        desc="Payload encoded according to the derivative protocol."
    )
    final_response: str = dspy.InputField(
        desc="ProtocolExecutor output to be validated."
    )
    verdict: str = dspy.OutputField(desc="pass or fail.")
    issues: list[str] = dspy.OutputField(
        desc="Short list of violations or empty if pass."
    )
