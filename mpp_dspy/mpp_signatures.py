from __future__ import annotations

import dspy


class ProtocolArchitect(dspy.Signature):
    """Generate an MPP bundle from a high-level user goal, ideally via refinement."""

    user_goal = dspy.InputField(desc="High-level user goal to be encoded.")
    meta_protocol_version = dspy.OutputField(desc="MPP spec version (e.g., 1.1.5).")
    derivative_protocol_specification = dspy.OutputField(
        desc="Derivative protocol specification object."
    )
    derivative_protocol_payload = dspy.OutputField(
        desc="Payload encoded according to the derivative protocol."
    )


class ProtocolExecutor(dspy.Signature):
    """Execute an MPP bundle, ideally via decode/validate refinement."""

    meta_protocol_version = dspy.InputField(desc="MPP spec version.")
    derivative_protocol_specification = dspy.InputField(
        desc="Derivative protocol specification object."
    )
    derivative_protocol_payload = dspy.InputField(
        desc="Payload encoded according to the derivative protocol."
    )
    final_response = dspy.OutputField(
        desc="Task output generated by the ProtocolExecutor."
    )


class QualityAssurance(dspy.Signature):
    """Validate the ProtocolExecutor output against the bundle."""

    meta_protocol_version = dspy.InputField(desc="MPP spec version.")
    derivative_protocol_specification = dspy.InputField(
        desc="Derivative protocol specification object."
    )
    derivative_protocol_payload = dspy.InputField(
        desc="Payload encoded according to the derivative protocol."
    )
    final_response = dspy.InputField(desc="ProtocolExecutor output to be validated.")
    verdict = dspy.OutputField(desc="pass or fail.")
    issues = dspy.OutputField(desc="Short list of violations or empty if pass.")
