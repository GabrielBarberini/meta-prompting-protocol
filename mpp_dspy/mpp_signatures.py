from __future__ import annotations

from collections.abc import Iterable, Mapping, Sequence
from dataclasses import dataclass
from typing import Any

import dspy

SchemaDescriptor = Sequence[str]

REQUIRED_BUNDLE_FIELDS = (
    "meta_protocol_version",
    "derivative_protocol_specification",
    "derivative_protocol_payload",
)
REQUIRED_SPEC_FIELDS = (
    "protocol_name",
    "abstract",
    "tag_definition_schema",
    "core_tag_library",
    "processor_semantics",
    "guiding_principles",
)


@dataclass(frozen=True)
class DerivativeProtocolSpecification:
    protocol_name: str
    abstract: str
    tag_definition_schema: SchemaDescriptor
    core_tag_library: Mapping[str, Mapping[str, Any]]
    processor_semantics: Mapping[str, str]
    guiding_principles: Mapping[str, Any]


@dataclass(frozen=True)
class MPPBundle:
    meta_protocol_version: str
    derivative_protocol_specification: DerivativeProtocolSpecification
    derivative_protocol_payload: Mapping[str, Any]


class ProtocolArchitect(dspy.Signature):
    """Generate an MPP bundle from a high-level user goal, ideally via refinement."""

    user_goal = dspy.InputField(desc="High-level user goal to be encoded.")
    meta_protocol_version = dspy.OutputField(desc="MPP spec version (e.g., 1.1.3).")
    derivative_protocol_specification = dspy.OutputField(
        desc="Derivative protocol specification object."
    )
    derivative_protocol_payload = dspy.OutputField(
        desc="Payload encoded according to the derivative protocol."

    )


class ProtocolExecutor(dspy.Signature):
    """Execute an MPP bundle, ideally via decode/validate refinement."""

    meta_protocol_version = dspy.InputField(desc="MPP spec version.")
    derivative_protocol_specification = dspy.InputField(
        desc="Derivative protocol specification object."
    )
    derivative_protocol_payload = dspy.InputField(
        desc="Payload encoded according to the derivative protocol."
    )
    final_response = dspy.OutputField(
        desc="Task output generated by the ProtocolExecutor."
    )


class QualityAssurance(dspy.Signature):
    """Validate the ProtocolExecutor output against the bundle."""

    meta_protocol_version = dspy.InputField(desc="MPP spec version.")
    derivative_protocol_specification = dspy.InputField(
        desc="Derivative protocol specification object."
    )
    derivative_protocol_payload = dspy.InputField(
        desc="Payload encoded according to the derivative protocol."
    )
    final_response = dspy.InputField(desc="ProtocolExecutor output to be validated.")
    verdict = dspy.OutputField(desc="pass or fail.")
    issues = dspy.OutputField(desc="Short list of violations or empty if pass.")


def validate_mpp_bundle(bundle: Mapping[str, Any]) -> None:
    """Lightweight structural checks for an MPP bundle dictionary."""
    _require_keys(bundle, REQUIRED_BUNDLE_FIELDS, "bundle")
    if not isinstance(bundle["meta_protocol_version"], str):
        raise TypeError("bundle.meta_protocol_version must be a string")

    spec = _require_mapping(
        bundle["derivative_protocol_specification"],
        "bundle.derivative_protocol_specification",
    )
    payload = _require_mapping(
        bundle["derivative_protocol_payload"],
        "bundle.derivative_protocol_payload",
    )
    validate_derivative_spec(spec)
    validate_payload(spec, payload)


def validate_derivative_spec(spec: Mapping[str, Any]) -> None:
    """Validate that the derivative spec matches the schema descriptor."""
    _require_keys(spec, REQUIRED_SPEC_FIELDS, "derivative_protocol_specification")
    schema = spec["tag_definition_schema"]
    if not _is_string_list(schema):
        raise TypeError(
            "tag_definition_schema must be an array of strings (e.g., ['description'])"
        )

    core_tag_library = _require_mapping(
        spec["core_tag_library"], "derivative_protocol_specification.core_tag_library"
    )
    processor_semantics = _require_mapping(
        spec["processor_semantics"],
        "derivative_protocol_specification.processor_semantics",
    )
    _require_mapping(
        spec["guiding_principles"],
        "derivative_protocol_specification.guiding_principles",
    )

    schema_fields = set(schema)
    for tag, tag_def in core_tag_library.items():
        tag_map = _require_mapping(tag_def, f"core_tag_library[{tag}]")
        missing_fields = schema_fields - set(tag_map.keys())
        if missing_fields:
            missing = ", ".join(sorted(missing_fields))
            raise ValueError(f"tag {tag} is missing required fields: {missing}")

        if "processor" in schema_fields:
            processor = tag_map.get("processor")
            if processor not in processor_semantics:
                raise ValueError(
                    f"tag {tag} references undefined processor: {processor}"
                )


def validate_payload(spec: Mapping[str, Any], payload: Mapping[str, Any]) -> None:
    """Ensure payload tags are declared in the core tag library."""
    core_tag_library = _require_mapping(
        spec["core_tag_library"], "derivative_protocol_specification.core_tag_library"
    )
    unknown_tags = set(payload.keys()) - set(core_tag_library.keys())
    if unknown_tags:
        unknown = ", ".join(sorted(unknown_tags))
        raise ValueError(f"payload includes unknown tags: {unknown}")


def _require_mapping(value: Any, label: str) -> Mapping[str, Any]:
    if not isinstance(value, Mapping):
        raise TypeError(f"{label} must be a mapping")
    return value


def _require_keys(container: Mapping[str, Any], required: Iterable[str], label: str) -> None:
    missing = [key for key in required if key not in container]
    if missing:
        missing_list = ", ".join(missing)
        raise ValueError(f"{label} is missing required keys: {missing_list}")


def _is_string_list(value: Any) -> bool:
    if isinstance(value, (str, bytes)) or not isinstance(value, Sequence):
        return False
    return all(isinstance(item, str) for item in value)
